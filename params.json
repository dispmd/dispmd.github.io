{"name":"Intelligent Distributed Power Management","tagline":"Building blocks for user-customizable non-uniform power allocation","body":"### About\r\n\r\nThis project provides building blocks for user-customizable non-uniform power allocation in distributed systems.\r\nUsing **software-based power monitoring and power capping** we implement **intelligent power provisioning under constraints** as a use-case.\r\n\r\n### Example\r\n\r\nSuppose you run a [Ceph](http://ceph.com/) cluster and now want to minimize its total power usage while still being able to service requests and prevent service degradation.\r\nAll you have to do is to specify the component's relationships.\r\n\r\n> Ceph object storage daemons depend on the monitor\r\n\r\n```clojure\r\n(=> (< scc.fs.ceph.mon0 20)\r\n    (and\r\n      (< scc.fs.ceph.osd0 10)\r\n      (< scc.fs.ceph.osd1 10)\r\n      (< scc.fs.ceph.osd2 10)))\r\n```\r\n\r\n> Replicas depend on the primary object storage daemon\r\n\r\n```clojure\r\n(=> (< scc.fs.ceph.osd0 20)\r\n    (and\r\n      (< scc.fs.ceph.osd1 20)\r\n      (< scc.fs.ceph.osd2 20)))\r\n```\r\n\r\n> Replicas and the primary object storage daemon must not exceed 50W\r\n\r\n```clojure\r\n(> 50\r\n   (+\r\n    scc.fs.ceph.osd0\r\n    scc.fs.ceph.osd1\r\n    scc.fs.ceph.osd2))\r\n```\r\n\r\nThis project then finds an optimal solution, optimizing the total power usage, propagating constraint to the endpoints and enforcing them locally.\r\nFor this, we merge local physical constraints such as the minimum and maximum allowed power draw for each server as well as global constraints such as the total power consumption with user-defined constraints.\r\n\r\n\r\n### Extensibility\r\n\r\nWe provide the architecture to monitor and power cap a distributed system's power usage from software.\r\nThis allows experimenting with interesting ideas such as intelligent power provisioning as shown above.\r\n\r\nFurther ideas in the context of distributed systems we wish to explore include\r\n\r\n* learning a distributed system's energy flow for prediction and outlier detection\r\n* analyzing CPU boundedness based on program slowdown under a CPU power limit\r\n* taking the energy market's time-of-use pricing model into account for power capping decisions\r\n\r\nThis project comes with a Python module to allow for rapid prototyping new ideas.\r\n\r\n### How\r\n\r\nThis project is written in C++14, making use of [Nanomsg](http://nanomsg.org/) for messaging and [Bond](https://github.com/Microsoft/bond) for serialization.\r\n[Z3's](https://github.com/Z3Prover/z3) optimizing SMT solver nuZ is used for solving the problem of finding the best solution under constraints.\r\nFinally we use the [Linux power capping framework](https://www.kernel.org/doc/Documentation/power/powercap/powercap.txt) with the [RAPL module](https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-class-powercap) to both monitor and limit power consumption from software.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}